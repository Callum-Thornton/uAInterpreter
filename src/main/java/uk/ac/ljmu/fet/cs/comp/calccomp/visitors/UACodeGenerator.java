/*
 *  ========================================================================
 *  uA Interpreter
 *  ========================================================================
 *  
 *  This file is part of ua Interpreter.
 *  
 *  ua Interpreter is free software: you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or (at
 *  your option) any later version.
 *  
 *  ua Interpreter is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of 
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with ua Interpreter.  If not, see <http://www.gnu.org/licenses/>.
 *  
 *  (C) Copyright 2017, Gabor Kecskemeti (g.kecskemeti@ljmu.ac.uk)
 */
package uk.ac.ljmu.fet.cs.comp.calccomp.visitors;

import uk.ac.ljmu.fet.cs.comp.calccomp.CalcHelperStructures;
import uk.ac.ljmu.fet.cs.comp.calccomp.interfaces.CalcVisitor;
import uk.ac.ljmu.fet.cs.comp.calccomp.tokens.CalcExpression;
import uk.ac.ljmu.fet.cs.comp.calccomp.tokens.CalcIntNumber;
import uk.ac.ljmu.fet.cs.comp.calccomp.tokens.Statement;
import uk.ac.ljmu.fet.cs.comp.calccomp.tokens.VariableRef;

public class UACodeGenerator implements CalcVisitor {
	StringBuilder generated = new StringBuilder();

	private static String printNumRetLabel = "retPrintNum";
	private static String endLabel = "exit:\nJMC exit\n";
	int labelCount = 0;
	boolean firstPrint = true;
	boolean firstStatement = true;

	@Override
	public void visit(CalcIntNumber e) {
	}

	@Override
	public void visit(Statement e) {
		if (firstStatement) {
			generated.append("entry:\n");
			// The top of the stack is 10001
			generated.append("MVC 10000,D\n");
			// Store the initial cursor position (i.e., the top of the screen)
			generated.append("MVC -80,A\n");
			generated.append("STC 10000,A\n");
			firstStatement = false;
		} else {
			// Make sure we remove the endlabel generated by the previous visit
			// This will guarantee that only one endlabel will be left in the code
			generated.setLength(generated.length() - endLabel.length());
		}
		generated.append("\nline");
		generated.append(e.myloc);
		generated.append(":\n");
		if (e.myKind == Statement.Kind.print) {
			if (firstPrint) {
				// Inserts the printNum function wherever we are and jumps over it
				firstPrint = false;
				generated.append("\n\n\n; BEGINNING OF Printnum function\n");
				generated.append("JMC afterPrintNum\n");
				generated.append("printNum:\n");
				generated.append("LDR D,A\n");
				generated.append("ADC -1,D\n");
				generated.append("LDR D,B\n");
				generated.append("ADC -1,D\n");
				generated.append("ADC 9,B\n");
				generated.append("hasMoreDigits:\n");
				generated.append("MVR A,C\n");
				generated.append("DVC 10,C\n");
				generated.append("MLC -10,C\n");
				generated.append("ADR A,C\n");
				generated.append("ADC 48,C\n");
				generated.append("STR B,C\n");
				generated.append("ADC -1,B\n");
				generated.append("DVC 10,A\n");
				generated.append("JZC hasMoreDigits,A\n");
				generated.append("LDR D,A\n");
				generated.append("ADC -1,D\n");
				generated.append("JMR A\n");
				generated.append("afterPrintNum:\n");
				generated.append("; END OF Printnum function \n\n\n");
			}
			// The actual printing
			String currLabel = printNumRetLabel + labelCount++;
			// push return address:
			generated.append("MVC ");
			generated.append(currLabel);
			generated.append(",A\n");
			generated.append("ADC 1,D\n");
			generated.append("STR D,A\n");
			// calc current position
			generated.append("LDC 10000,A\n");
			// Moving to the next line:
			generated.append("ADC 80,A\n");
			// Modulo 2000:
			generated.append("MVR A,B\n");
			generated.append("DVC 2000,B\n");
			generated.append("MLC -2000,B\n");
			generated.append("ADR B,A\n");
			generated.append("STC 10000,A\n");
			// Storing the calculated position to the stack
			generated.append("ADC 1,D\n");
			generated.append("STR D,A\n");
			// Storing the to be printed value on the stack
			loadToReg(e.target, "A");
			generated.append("ADC 1,D\n");
			generated.append("STR D,A\n");
			generated.append("JMC printNum\n");
			// Placing the return label
			generated.append(currLabel);
			generated.append(":\n");
		} else {
			loadToReg(e.left,"A");
			if (e.myKind != null) {
				loadToReg(e.right,"B");
				switch (e.myKind) {
				case add:
					generated.append("ADR");
					break;
				case divide:
					generated.append("DVR");
					break;
				case multiply:
					generated.append("MLR");
					break;
				case subtract:
					generated.append("MLC -1,B\n");
					generated.append("ADR");
					break;
				default:
					throw new Error("Illegal state in the code generator at line " + e.myloc);
				}
				generated.append(" B,A\n");
			}
			generated.append("STC ");
			generated.append(CalcHelperStructures.globalSymbolTable.get(e.target.myId).memLoc);
			generated.append(",A\n");
		}
		// Showing that we are at the end
		generated.append(endLabel);
	}

	private void loadToReg(CalcExpression ce, String target) {
		if (ce instanceof VariableRef) {
			generated.append("LDC ");
			generated.append(CalcHelperStructures.globalSymbolTable.get(((VariableRef) ce).myId).memLoc);
		} else {
			generated.append("MVC ");
			generated.append(((CalcIntNumber) ce).number);
		}
		generated.append(",");
		generated.append(target);
		generated.append("\n");
	}

	@Override
	public void visit(VariableRef e) {
	}

	public String getGenerated() {
		return generated.toString();
	}
}
