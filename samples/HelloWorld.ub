~
~  ========================================================================
~  uB Interpreter
~  ========================================================================
~  
~  This file is sample source code for the uB Interpreter.
~  
~  uB Interpreter is free software: you can redistribute it and/or
~  modify it under the terms of the GNU General Public License as published
~  by the Free Software Foundation, either version 3 of the License, or (at
~  your option) any later version.
~  
~  uB Interpreter is distributed in the hope that it will be useful,
~  but WITHOUT ANY WARRANTY; without even the implied warranty of 
~  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
~  General Public License for more details.
~
~  You should have received a copy of the GNU General Public License along
~  with uB Interpreter.  If not, see <http://www.gnu.org/licenses/>.
~  
~  (C) Copyright 2018, Gabor Kecskemeti (g.kecskemeti@ljmu.ac.uk)
~

~ Demonstrates how a hello world program could be written in uB
~ One can vary the location of the printout by setting the memory
~   locations of 10001 and 10001 (for x and y coordinates respectively)

~ This sample shows features like:
~ 1. Function calls with parameter passing through the memory
~ 2. Return from a function call to the part of the program pointed
~         to in a given memory location
~ 3. Zero terminated string handling (i.e, tell the end of the string
~         by seeing a character with the ASCII code 0)
~    3a) see the line with COND loop,A (which checks if A is 0 or not)
~ 4. Calculating position on the screen (see: MULI 80,D and ADDI D,C)

STR hwstr Hello World from 
NUMBER greeku 956
STR hwcomplete B!
NUMBER terminatehwstr 0

:start
	~ setting up the parameters for printat
MOVE hwstr,@10000
MOVE 30,@10001
MOVE 12,@10002
	~ telling printat to return to our exit infinite loop
MOVE stop, @10003
	~ calling printat
JUMP printAt
:stop

:printAt
	~ Par2: X
MOVE @10001,C
	~ Par3: Y
MOVE @10002,D
	~ Row conversion
MULI 80,D
	~ C is now linear loc
ADDI D,C
	~ Par1: string
MOVE @10000,B
:loop
MOVE @B, A
MOVE A, @C
ADDI 1,B
ADDI 1,C
COND loop, A
MOVE @10003,A
	~ Return where we were told so
JUMP A
